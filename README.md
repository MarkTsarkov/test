# test
```docker compose up -d```

При запуске миграции накатятся посредством goose через отдельный контейнер-мигратор

В ходе разработки решения я поднял возможную нагрузку с ~100 до ~350-450 rps на *mac m1 8гб озу*
Задействовал параллельную отправку и запись кликов
В базу данных клики отправляются пачками каждую секунду (1 запрос на всю пачку)

nginx остался как артефакт проверки гипотез, но особой роли не сыграл

В конечном счете из 5000 запросов со скоростью 500rps доходит от 3500 до 4500 кликов
Также пробовал закинуть 25000 запросов со скоростью 5k rps и получил около 66% кликов

В конечном счете при 150rps доходят все

***Как бы я улучшил решение***
1) Накинул бы CPU -> график нагрузки на nginx показал исчерпание почти всех ресурсов на 500rps+
2) Брокер и кэш для получения и хранения кликов до отправки их в базу данных -> чтобы клики не потерялись, ведь статистика это важно
3) Внедрил бы uberFX для здоровой инъекции зависимостей и запуска параллельного сендера
4) Логи, конфиги - все само собой разумеющееся

**Дополнительно**
Думаю, что в условиях ограниченного cpu можно попробовать поиграться с воркерами, ограничив их до 200 (это примерная граница когда все клики доходят), 
и оставив внутреннюю очередь для задач, которая наполняется с каждым кликом (сейчас это s.clicksCh). Так работа приложения замедлится и придется хранить 
все в памяти, но все клики рано или поздно дойдут до места назначения.
